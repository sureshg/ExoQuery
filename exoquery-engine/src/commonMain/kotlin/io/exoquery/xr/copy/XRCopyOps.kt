package io.exoquery.xr.copy

// TODO probably want this to be auto-generated by Decomat similar to the csf functions
//      etc... but it needs to be generated in a different package because we DONT want to import XR.Elem.Elem functions everywhere

import io.exoquery.BID
import io.exoquery.xr.*
import io.exoquery.xr.XR.Assignment
import io.exoquery.xr.XR.Batching
import io.exoquery.xr.XR.ConcatMap
import io.exoquery.xr.XR.Entity
import io.exoquery.xr.XR.Filter
import io.exoquery.xr.XR.Map
import io.exoquery.xr.XR.ExprToQuery
import io.exoquery.xr.XR.QueryToExpr
import io.exoquery.xr.XR.SortBy
import io.exoquery.xr.XR.Take
import io.exoquery.xr.XR.Drop
import io.exoquery.xr.XR.Union
import io.exoquery.xr.XR.UnionAll
import io.exoquery.xr.XR.FlatMap
import io.exoquery.xr.XR.FlatJoin
import io.exoquery.xr.XR.FlatGroupBy
import io.exoquery.xr.XR.FlatSortBy
import io.exoquery.xr.XR.FlatFilter
import io.exoquery.xr.XR.FlatHaving
import io.exoquery.xr.XR.Distinct
import io.exoquery.xr.XR.DistinctOn
import io.exoquery.xr.XR.Nested
import io.exoquery.xr.XR.Free
import io.exoquery.xr.XR.FunctionN
import io.exoquery.xr.XR.FunctionApply
import io.exoquery.xr.XR.BinaryOp
import io.exoquery.xr.XR.UnaryOp
import io.exoquery.xr.XR.MethodCall
import io.exoquery.xr.XR.GlobalCall
import io.exoquery.xr.XR.Ident
import io.exoquery.xr.XR.TagForSqlExpression
import io.exoquery.xr.XR.TagForSqlQuery
import io.exoquery.xr.XR.TagForParam
import io.exoquery.xr.XR.Product
import io.exoquery.xr.XR.Property
import io.exoquery.xr.XR.Block
import io.exoquery.xr.XR.When
import io.exoquery.xr.XR.Branch
import io.exoquery.xr.XR.CustomQueryRef
import io.exoquery.xr.XR.Delete
import io.exoquery.xr.XR.FilteredAction
import io.exoquery.xr.XR.Insert
import io.exoquery.xr.XR.OnConflict
import io.exoquery.xr.XR.Returning
import io.exoquery.xr.XR.Update
import io.exoquery.xr.XR.Variable
import io.exoquery.xr.XR.Window

val Entity.Entity get() = this
fun Entity.cs(name: String) = io.exoquery.xr.XR.Entity.csf(name)(this)

val Filter.Filter get() = this
fun Filter.cs(head: XR.Query, id: XR.Ident, body: XR.Expression) = io.exoquery.xr.XR.Filter.csf(head, id, body)(this)

val Map.Map get() = this
fun Map.cs(head: XR.Query, id: XR.Ident, body: XR.Expression) = io.exoquery.xr.XR.Map.csf(head, id, body)(this)

val ConcatMap.ConcatMap get() = this
fun ConcatMap.cs(head: XR.Query, id: XR.Ident, body: XR.Expression) = io.exoquery.xr.XR.ConcatMap.csf(head, id, body)(this)

val QueryToExpr.QueryToExpr get() = this
fun QueryToExpr.cs(head: XR.Query) = io.exoquery.xr.XR.QueryToExpr.csf(head)(this)

val ExprToQuery.ExprToQuery get() = this
fun ExprToQuery.cs(head: XR.Expression) = io.exoquery.xr.XR.ExprToQuery.csf(head)(this)

val SortBy.SortBy get() = this
fun SortBy.cs(head: XR.Query, id: XR.Ident, criteria: List<XR.OrderField>) = io.exoquery.xr.XR.SortBy.csf(head, id, criteria)(this)

val Take.Take get() = this
fun Take.cs(head: XR.Query, num: XR.Expression) = io.exoquery.xr.XR.Take.csf(head, num)(this)

val Drop.Drop get() = this
fun Drop.cs(head: XR.Query, num: XR.Expression) = io.exoquery.xr.XR.Drop.csf(head, num)(this)

val Union.Union get() = this
fun Union.cs(a: XR.Query, b: XR.Query) = io.exoquery.xr.XR.Union.csf(a, b)(this)

val UnionAll.UnionAll get() = this
fun UnionAll.cs(a: XR.Query, b: XR.Query) = io.exoquery.xr.XR.UnionAll.csf(a, b)(this)

val FlatMap.FlatMap get() = this
fun FlatMap.cs(head: XR.Query, id: XR.Ident, body: XR.Query) = io.exoquery.xr.XR.FlatMap.csf(head, id, body)(this)

val FlatJoin.FlatJoin get() = this
fun FlatJoin.cs(head: XR.Query, id: XR.Ident, on: XR.Expression) = io.exoquery.xr.XR.FlatJoin.csf(head, id, on)(this)

val FlatGroupBy.FlatGroupBy get() = this
fun FlatGroupBy.cs(by: XR.Expression) = io.exoquery.xr.XR.FlatGroupBy.csf(by)(this)

val FlatSortBy.FlatSortBy get() = this
fun FlatSortBy.cs(criteria: List<XR.OrderField>) = io.exoquery.xr.XR.FlatSortBy.csf(criteria)(this)

val FlatFilter.FlatFilter get() = this
fun FlatFilter.cs(by: XR.Expression) = io.exoquery.xr.XR.FlatFilter.csf(by)(this)

val FlatHaving.FlatHaving get() = this
fun FlatHaving.cs(by: XR.Expression) = io.exoquery.xr.XR.FlatHaving.csf(by)(this)

val Distinct.Distinct get() = this
fun Distinct.cs(head: XR.Query) = io.exoquery.xr.XR.Distinct.csf(head)(this)

val DistinctOn.DistinctOn get() = this
fun DistinctOn.cs(head: XR.Query, id: XR.Ident, by: XR.Expression) = io.exoquery.xr.XR.DistinctOn.csf(head, id, by)(this)

val Nested.Nested get() = this
fun Nested.cs(head: XR.Query) = io.exoquery.xr.XR.Nested.csf(head)(this)

val Free.Free get() = this
fun Free.cs(parts: List<String>, params: List<XR>) = io.exoquery.xr.XR.Free.csf(parts, params)(this)

val FunctionN.FunctionN get() = this
fun FunctionN.cs(params: List<Ident>, body: XR.U.QueryOrExpression) = io.exoquery.xr.XR.FunctionN.csf(params, body)(this)

val FunctionApply.FunctionApply get() = this
fun FunctionApply.cs(function: XR.U.QueryOrExpression, args: List<XR.U.QueryOrExpression>) = io.exoquery.xr.XR.FunctionApply.csf(function, args)(this)

val BinaryOp.BinaryOp get() = this
fun BinaryOp.cs(a: XR.Expression, op: BinaryOperator, b: XR.Expression) = io.exoquery.xr.XR.BinaryOp.csf(a, op, b)(this)

val UnaryOp.UnaryOp get() = this
fun UnaryOp.cs(op: UnaryOperator, expr: XR.Expression) = io.exoquery.xr.XR.UnaryOp.csf(op, expr)(this)

val MethodCall.MethodCall get() = this
fun MethodCall.cs(head: XR.U.QueryOrExpression, args: List<XR.U.QueryOrExpression>) = io.exoquery.xr.XR.MethodCall.csf(head, name, args)(this)

val GlobalCall.GlobalCall get() = this
fun GlobalCall.cs(args: List<XR.U.QueryOrExpression>) = io.exoquery.xr.XR.GlobalCall.csf(name, args)(this)

val Ident.Ident get() = this
fun Ident.cs(name: String) = io.exoquery.xr.XR.Ident.csf(name)(this)

val TagForSqlExpression.TagForSqlExpression get() = this
fun TagForSqlExpression.cs(id: BID) = io.exoquery.xr.XR.TagForSqlExpression.csf(id)(this)

val TagForSqlQuery.TagForSqlQuery get() = this
fun TagForSqlQuery.cs(id: BID) = io.exoquery.xr.XR.TagForSqlQuery.csf(id)(this)

val TagForParam.TagForParam get() = this
fun TagForParam.cs(id: BID) = io.exoquery.xr.XR.TagForParam.csf(id)(this)

val Product.Product get() = this
fun Product.cs(fields: List<Pair<String, XR.Expression>>) = io.exoquery.xr.XR.Product.csf(fields)(this)

val Property.Property get() = this
fun Property.cs(of: XR.Expression, name: String) = io.exoquery.xr.XR.Property.csf(of, name)(this)

val Block.Block get() = this
fun Block.cs(stmts: List<Variable>, output: XR.Expression) = io.exoquery.xr.XR.Block.csf(stmts, output)(this)

val When.When get() = this
fun When.cs(branches: List<Branch>, orElse: XR.Expression) = io.exoquery.xr.XR.When.csf(branches, orElse)(this)

val Branch.Branch get() = this
fun Branch.cs(cond: XR.Expression, then: XR.Expression) = io.exoquery.xr.XR.Branch.csf(cond, then)(this)

val Variable.Variable get() = this
fun Variable.cs(name: XR.Ident, rhs: XR.Expression) = io.exoquery.xr.XR.Variable.csf(name, rhs)(this)

val Assignment.Assignment get() = this
fun Assignment.cs(property: XR.Property, value: XR.Expression) = io.exoquery.xr.XR.Assignment.csf(property, value)(this)

val Insert.Insert get() = this
fun Insert.cs(query: XR.Entity, alias: XR.Ident, assignments: List<XR.Assignment>, exclusions: List<XR.Property>) = io.exoquery.xr.XR.Insert.csf(query, alias, assignments, exclusions)(this)

val Update.Update get() = this
fun Update.cs(query: XR.Entity, alias: XR.Ident, assignments: List<XR.Assignment>, exclusions: List<XR.Property>) = io.exoquery.xr.XR.Update.csf(query, alias, assignments, exclusions)(this)

val Delete.Delete get() = this
fun Delete.cs(query: XR.Entity, alias: XR.Ident) = io.exoquery.xr.XR.Delete.csf(query, alias)(this)

val OnConflict.OnConflict get() = this
fun OnConflict.cs(action: XR.Insert, target: XR.OnConflict.Target, resolution: XR.OnConflict.Resolution) = io.exoquery.xr.XR.OnConflict.csf(action, target, resolution)(this)

val FilteredAction.FilteredAction get() = this
fun FilteredAction.cs(action: XR.U.CoreAction, alias: XR.Ident, filter: XR.Expression) = io.exoquery.xr.XR.FilteredAction.csf(action, alias, filter)(this)

val Returning.Returning get() = this
fun Returning.cs(action: XR.Action, kind: Returning.Kind) = io.exoquery.xr.XR.Returning.csf(action, kind)(this)

val Batching.Batching get() = this
fun Batching.cs(alias: XR.Ident, action: XR.Action) = io.exoquery.xr.XR.Batching.csf(alias, action)(this)

val CustomQueryRef.CustomQueryRef get() = this
fun CustomQueryRef.cs(customQuery: XR.CustomQuery) = io.exoquery.xr.XR.CustomQueryRef.csf(customQuery)(this)

val Window.Window get() = this
fun Window.cs(partitionBy: List<XR.Expression>, orderBy: List<XR.OrderField>, over: XR.Expression) = io.exoquery.xr.XR.Window.csf(partitionBy, orderBy, over)(this)
